# HackerRank ProjectEuler+ Problem 29: Distinct Powers
# https://www.hackerrank.com/contests/projecteuler/challenges/euler029/problem
#
# Project Euler: https://projecteuler.net/problem=29
# Solution: https://aliramadhan.me/blog/project-euler/problem-0029/
#
# Problem Statement:
#   Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#
#   2^2 = 4,  2^3 = 8,   2^4 = 16,  2^5 = 32
#   3^2 = 9,  3^3 = 27,  3^4 = 81,  3^5 = 243
#   4^2 = 16, 4^3 = 64,  4^4 = 256, 4^5 = 1024
#   5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125
#
#   If they are then placed in numerical order, with any repeats removed, we get
#   the following sequence of 15 distinct terms:
#   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125.
#
#   How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ N
#   and 2 ≤ b ≤ N?
#
# Input Format:
#   Input contains an integer N.
#
# Constraints:
#   2 ≤ N ≤ 10^5
#
# Output Format:
#   Print the answer corresponding to the test case.
#
# Sample Input:
#   5
#
# Sample Output:
#   15

function count_distinct_powers(b_max::Int)
    max_log = floor(Int, log2(b_max))

    # Precompute S_m = |⋃_{j=1}^m {jb : 2 ≤ b ≤ b_max}| for m = 1 to log₂(b_max)
    unique_exponent_counts = Vector{Int}(undef, max_log)
    for m in 1:max_log
        seen = Set{Int}()
        for j in 1:m
            for b in 2:b_max
                push!(seen, j * b)
            end
        end
        unique_exponent_counts[m] = length(seen)
    end

    # Find primitive roots and sum their contributions
    is_perfect_power = falses(b_max)
    result = 0

    for base in 2:b_max
        if is_perfect_power[base]
            continue
        end

        # Count how many powers of base are ≤ b_max
        power_count = 1
        val = base
        while true
            next_val = val * base
            if next_val > b_max
                break
            end
            val = next_val
            power_count += 1
            is_perfect_power[val] = true
        end

        result += unique_exponent_counts[power_count]
    end

    return result
end

b_max = parse(Int, readline())
println(count_distinct_powers(b_max))
