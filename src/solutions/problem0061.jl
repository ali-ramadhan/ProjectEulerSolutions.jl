"""
Project Euler Problem 61: Cyclical Figurate Numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate
(polygonal) numbers and are generated by the following formulae:

Triangle: P[3,n] = n(n+1)/2    1, 3, 6, 10, 15, ...
Square: P[4,n] = n²            1, 4, 9, 16, 25, ...
Pentagonal: P[5,n] = n(3n-1)/2 1, 5, 12, 22, 35, ...
Hexagonal: P[6,n] = n(2n-1)    1, 6, 15, 28, 45, ...
Heptagonal: P[7,n] = n(5n-3)/2 1, 7, 18, 34, 55, ...
Octagonal: P[8,n] = n(3n-2)    1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting
properties:
 1. The set is cyclic, in that the last two digits of each number is the first two digits of
    the next number (including the last number with the first).
 2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281), and pentagonal
    (P[5,44]=2882), is represented by a different number in the set.
 3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal
type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by
a different number in the set.

## Solution approach

This problem uses a backtracking search algorithm to find cyclical figurate numbers:
1. Generate all 4-digit figurate numbers for each type (triangle, square, pentagonal,
   hexagonal, heptagonal, octagonal)
2. Use recursive backtracking to build cycles: for each starting number and type, try to
   extend the cycle by finding numbers whose first two digits match the last two digits of
   the current number
3. When we have 6 numbers, check if the cycle closes (last number's suffix matches first
   number's prefix)
4. Return the sum of the first valid cycle found

## Complexity analysis

Time complexity: O(N^6) in worst case where N ≈ 300 is the number of 4-digit figurate
numbers per type
- We generate ~300 figurate numbers per type (6 types total)
- Backtracking explores at most 6 levels deep with branching factor ~300
- However, the constraint that digits must match significantly prunes the search space

Space complexity: O(N)
- Storage for figurate numbers: ~1800 numbers total
- Recursion depth: O(6) for the backtracking
- Overall dominated by storage of figurate numbers

## Key insights

The key optimization is using the cyclical property to dramatically prune the search space -
at each step we only consider numbers whose first two digits match the current number's last
two digits, reducing the branching factor from ~300 to typically just a few candidates.
"""
module Problem0061

"""
    figurate_number(s, n)

Calculate the nth s-gonal (figurate) number. For s=3 (triangle), s=4 (square), s=5
(pentagonal), etc.
"""
@inline function figurate_number(s, n)
    return n * ((s - 2) * n - (s - 4)) ÷ 2
end

"""
    generate_figurate_numbers(s, min_val, max_val)

Generate figurate numbers of type s (3 for triangle, 4 for square, etc.) that are within the
range [min_val, max_val].
"""
function generate_figurate_numbers(s, min_val, max_val)
    result = Int[]
    n = 1

    while true
        p = figurate_number(s, n)

        if p > max_val
            break
        end

        if p >= min_val
            push!(result, p)
        end

        n += 1
    end

    return result
end

"""
    find_cycle(path, used_types, figurate_by_type)

Recursively find a cyclical set of figurate numbers. Returns the path if a cyclical set is
found, nothing otherwise.
"""
function find_cycle(path, used_types, figurate_by_type)
    # If we have all 6 numbers, check if the cycle is complete
    if length(path) == 6
        (last_num, _) = path[end]
        (first_num, _) = path[1]

        last_two = last_num % 100
        first_two = first_num ÷ 100

        # Last number's last two digits should match first number's first two digits
        return last_two == first_two ? path : nothing
    end

    # Get the last two digits of the current number
    (last_num, _) = path[end]
    last_two = last_num % 100

    # Try each figurate type as next in the cycle
    for next_type in 3:8
        if next_type in used_types
            continue
        end

        # Check all numbers of the current type
        for next_num in figurate_by_type[next_type]
            next_first_two = next_num ÷ 100

            # If the number forms a chain with our current number
            if next_first_two == last_two
                push!(path, (next_num, next_type))
                push!(used_types, next_type)

                result = find_cycle(path, used_types, figurate_by_type)

                if !isnothing(result)
                    return result
                end

                # Backtrack
                pop!(path)
                delete!(used_types, next_type)
            end
        end
    end

    return nothing
end

"""
    find_cyclical_set()

Find the ordered set of six cyclic 4-digit numbers where each number is a different figurate
type (triangle, square, pentagonal, hexagonal, heptagonal, and octagonal). Returns the sum
of these numbers.
"""
function find_cyclical_set()
    min_val, max_val = 1000, 9999
    figurate_by_type = Dict{Int, Vector{Int}}()

    for s in 3:8
        figurate_by_type[s] = generate_figurate_numbers(s, min_val, max_val)
    end

    for start_type in 3:8
        for start_num in figurate_by_type[start_type]
            result =
                find_cycle([(start_num, start_type)], Set([start_type]), figurate_by_type)

            if !isnothing(result)
                cyclical_numbers = [num for (num, _) in result]
                types = [type for (_, type) in result]
                @info "Found cyclical figurate numbers: $cyclical_numbers with types $types"
                return sum(cyclical_numbers)
            end
        end
    end

    return nothing
end

function solve()
    return find_cyclical_set()
end

end # module
