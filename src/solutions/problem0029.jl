"""
Project Euler Problem 29: Distinct Powers

Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2 = 4,  2^3 = 8,   2^4 = 16,  2^5 = 32
3^2 = 9,  3^3 = 27,  3^4 = 81,  3^5 = 243
4^2 = 16, 4^3 = 64,  4^4 = 256, 4^5 = 1024
5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125

If they are then placed in numerical order, with any repeats removed, we get the following
sequence of 15 distinct terms: 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024,
3125.

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤
100?

## Solution approach

We use a logarithm-based approach to avoid computing large powers:
1. Instead of computing a^b directly, compute b × log(a)
2. Two powers are equal iff their logarithms are equal: a^b = c^d ⟺ b×log(a) = d×log(c)
3. Sort the logarithm values and count adjacent pairs that differ by more than ε
4. The tolerance ε = 1e-10 handles floating-point precision while being small enough
   to distinguish truly different powers

This approach is ~200x faster than BigInt for large inputs (n=1000).

## Complexity analysis

Time complexity: O(n² log n)
- We compute n² = 99² logarithm products in O(n²)
- Sorting takes O(n² log n²) = O(n² log n)

Space complexity: O(n²)
- We store n² Float64 values (8 bytes each)
"""
module Problem0029

export count_distinct_powers, solve

"""
    count_distinct_powers(a_min, a_max, b_min, b_max)

Count the number of distinct terms in the sequence generated by a^b for
a_min ≤ a ≤ a_max and b_min ≤ b ≤ b_max.

Uses logarithms to avoid computing large powers: a^b = c^d ⟺ b×log(a) = d×log(c).
"""
function count_distinct_powers(a_min, a_max, b_min, b_max; similarity_threshold=1e-10)
    powers = Float64[]
    sizehint!(powers, (a_max - a_min + 1) * (b_max - b_min + 1))

    for a in a_min:a_max
        loga = log(a)
        for b in b_min:b_max
            push!(powers, b * loga)
        end
    end

    sort!(powers)

    count = 1
    for i in 2:length(powers)
        if powers[i] - powers[i-1] > similarity_threshold
            count += 1
        end
    end

    return count
end

function solve()
    return count_distinct_powers(2, 100, 2, 100)
end

end # module
